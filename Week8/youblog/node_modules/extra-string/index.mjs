function IDENTITY(v) {
    return v;
}

const DIGITS = "0123456789";
const OCT_DIGITS = "01234567";
const HEX_DIGITS = "0123456789ABCDEFabcdef";
const UPPERCASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const LOWERCASE = "abcdefghijklmnopqrstuvwxyz";
const LETTERS = UPPERCASE + LOWERCASE;
const PUNCTUATION = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
const WHITESPACE = "\t\n\x0b\x0c\r ";
const PRINTABLE = DIGITS + LETTERS + PUNCTUATION + WHITESPACE;
const MIN_CODE_POINT = 0x000000;
const MAX_CODE_POINT = 0x10FFFF;
function fromCharCode(...codes) {
    return String.fromCharCode(...codes);
}
function fromCodePoint(...codes) {
    return String.fromCodePoint(...codes);
}
function concat(...values) {
    return "".concat(...values);
}
function repeat(x, times) {
    return x.repeat(times);
}
function valueOf(x) {
    return x.valueOf();
}
function length(x) {
    return x.length;
}
function charAt(x, at) {
    return x.charAt(at);
}
function charCodeAt(x, at) {
    return x.charCodeAt(at);
}
function codePointAt(x, at) {
    return x.codePointAt(at);
}
function localeCompare(x, y, locales, options) {
    return x.localeCompare(y, locales, options);
}
function includes(x, infix, start) {
    return x.includes(infix, start);
}
function startsWith(x, prefix, start) {
    return x.startsWith(prefix, start);
}
function endsWith(x, suffix, end) {
    return x.endsWith(suffix, end);
}
function indexOf(x, infix, start) {
    return x.indexOf(infix, start);
}
function lastIndexOf(x, infix, rstart) {
    return x.lastIndexOf(infix, rstart);
}
function search(x, regexp) {
    return x.search(regexp);
}
function match(x, regexp) {
    return x.match(regexp);
}
function matchAll(x, regexp) {
    return x.matchAll(regexp);
}
function toString(x) {
    return x.toString();
}
function slice(x, start, end) {
    return x.slice(start, end);
}
function substring(x, start, end) {
    return x.substring(start, end);
}
function split(x, separator, limit) {
    return x.split(separator, limit);
}
function trimStart(x) {
    return x.trimStart();
}
function trimEnd(x) {
    return x.trimEnd();
}
function trim(x) {
    return x.trim();
}
function padStart(x, length, padding = " ") {
    return x.padStart(length, padding);
}
function padEnd(x, length, padding = " ") {
    return x.padEnd(length, padding);
}
function toUpperCase(x) {
    return x.toUpperCase();
}
function toLocaleUpperCase(x, locales) {
    return x.toLocaleUpperCase(locales);
}
function toLowerCase(x) {
    return x.toLowerCase();
}
function toLocaleLowerCase(x, locales) {
    return x.toLocaleLowerCase(locales);
}
function replace(x, pattern, replacement) {
    return x.replace(pattern, replacement);
}
function normalize(x, form) {
    return x.normalize(form);
}
function of(...args) {
    var a = "";
    for (var i = 0, I = args.length; i < I; i++)
        a += args[i];
    return a;
}
function from(xs, fm, ths) {
    var a = "", i = 0;
    for (var x of xs) {
        a += fm ? fm.call(ths, x, i) : x;
        i++;
    }
    return a;
}
function splice(x, start, remove = 0, add = "") {
    return x.slice(0, start) + add + x.slice(start + remove);
}
function reverse(x) {
    return [...x].reverse().join("");
}
function sort(x, fc) {
    return [...x].sort(fc).join("");
}
function filter(x, ft, ths) {
    var a = "", i = 0;
    for (var c of x)
        if (ft.call(ths, c, i++))
            a += c;
    return a;
}
const SPACE_BUFFER = " ".repeat(1024);
function spaces(n) {
    var S = SPACE_BUFFER.length;
    if (n < S)
        return SPACE_BUFFER.slice(0, n);
    return SPACE_BUFFER.repeat(n / S) + " ".repeat(n % S);
}
function is(v) {
    return typeof v === "string";
}
function isEmpty(x) {
    return x.length === 0;
}
function isCharacter(x) {
    return x.length === 1;
}
function index(x, at) {
    if (at < 0)
        return Math.max(0, x.length + at);
    return Math.min(at, x.length);
}
function indexRange(x, start, end) {
    start = index(x, start);
    end = index(x, end);
    return [Math.min(start, end), Math.max(start, end)];
}
function codePointRange(x) {
    var min = MAX_CODE_POINT;
    var max = MIN_CODE_POINT;
    for (var c of x) {
        var v = c.codePointAt(0);
        min = Math.min(min, v);
        max = Math.max(max, v);
    }
    return [min, max];
}
function compare(x, y) {
    return x < y ? -1 : (x > y ? 1 : 0);
}
function isEqual(x, y) {
    return x === y;
}
function get(x, at) {
    return x.charAt(at >= 0 ? at : x.length + at);
}
function getAll(x, ats) {
    var a = "";
    for (var at of ats)
        a += get(x, at);
    return a;
}
function set(x, at, write) {
    return x.slice(0, at) + write + x.slice(at + write.length);
}
function begin(x, count = 1) {
    return x.slice(0, count);
}
function middle(x, start, count = 1) {
    return x.slice(start, start + count);
}
function end(x, count = 1) {
    return x.slice(x.length - count);
}
function longestCommonInfix(x, y) {
    var ai = 0, al = 0;
    for (var i = 0, I = x.length; i < I; i++) {
        for (var j = 0, J = y.length, l = 0; j < J; j++) {
            l = x[i + l] === y[j] ? l + 1 : 0;
            if (l > al) {
                ai = j - l + 1;
                al = l;
            }
        }
    }
    return y.substring(ai, ai + al);
}
function longestCommonPrefix(x, y) {
    for (var i = 0, I = Math.min(x.length, y.length); i < I; i++)
        if (x[i] !== y[i])
            break;
    return x.substring(0, i);
}
function longestCommonSuffix(x, y) {
    for (var i = x.length - 1, j = y.length - 1; i >= 0 && j >= 0; i--, j--)
        if (x[i] !== y[j])
            break;
    return x.substring(i + 1);
}
function longestUncommonInfixes(x, y) {
    var X = x.length, Y = y.length;
    var i = longestCommonPrefix(x, y).length;
    var j = longestCommonSuffix(x, y).length;
    return [x.substring(i, X - j), y.substring(i, Y - j)];
}
const SUPERSCRIPT_SOURCE = "⁰¹²³⁴⁵⁶⁷⁸⁹⁺⁻⁼⁽⁾ᵝᵞᵟᶿᶥᵠᵡᴬᴮᴰᴱᴳᴴᴵᴶᴷᴸᴹᴺᴼᴾᴿᵀᵁⱽᵂᶦᶫᶰᶸᵃᵇᶜᵈᵉᶠᵍʰⁱʲᵏˡᵐⁿᵒᵖʳˢᵗᵘᵛʷˣʸᶻ";
const SUPERSCRIPT_TARGET = "0123456789+-=()βγδθιφχABDEGHIJKLMNOPRTUVWILNUabcdefghijklmnoprstuvwxyz";
const SUBSCRIPT_SOURCE = "₀₁₂₃₄₅₆₇₈₉₊₋₌₍₎ₔᵦᵧᵨᵩᵪₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓ";
const SUBSCRIPT_TARGET = "0123456789+-=()əβγρφχaehijklmnoprstuvx";
function toBaselineDirect(x) {
    var a = "";
    for (var c of x) {
        var j = SUPERSCRIPT_SOURCE.indexOf(c);
        var k = SUBSCRIPT_SOURCE.indexOf(c);
        if (j >= 0)
            c = SUPERSCRIPT_TARGET[j];
        if (k >= 0)
            c = SUPERSCRIPT_TARGET[k];
        a += c;
    }
    return a;
}
function toBaselineIndirect(x, fsup, fsub) {
    var a = "", i = 0;
    var tmp = "", mode = 0;
    fsup = fsup || IDENTITY;
    fsub = fsub || IDENTITY;
    for (var c of x) {
        var t = tmp.length;
        var j = SUPERSCRIPT_SOURCE.indexOf(c);
        var k = SUBSCRIPT_SOURCE.indexOf(c);
        var m = (j >= 0 ? 1 : 0) + (k >= 0 ? 2 : 0);
        if (m !== mode && t)
            a += mode === 0 ? tmp : (mode === 1 ? fsup(tmp, i - t) : fsub(tmp, i - t));
        tmp += m === 0 ? c : (m === 1 ? SUPERSCRIPT_TARGET[j] : SUBSCRIPT_TARGET[k]);
        mode = m;
        i++;
    }
    if (tmp)
        a += mode === 0 ? tmp : (mode === 1 ? fsup(tmp, i - t) : fsub(tmp, i - t));
    return a;
}
function toBaseline(x, fsup = null, fsub = null) {
    if (!fsup && !fsub)
        return toBaselineDirect(x);
    return toBaselineIndirect(x, fsup || IDENTITY, fsub || IDENTITY);
}
const SUPERSCRIPT_LOOKUP = "        ⁽⁾ ⁺ ⁻  ⁰¹²³⁴⁵⁶⁷⁸⁹   ⁼   ᴬᴮ ᴰᴱ ᴳᴴᴵᴶᴷᴸᴹᴺᴼᴾ ᴿ ᵀᵁ ᵂ         ᵃᵇᶜᵈᵉᶠᵍʰⁱʲᵏˡᵐⁿᵒᵖ ʳˢᵗᵘᵛʷˣʸᶻ     ";
function toSuperscript(x) {
    var a = "";
    for (var c of x) {
        var d = SUPERSCRIPT_LOOKUP[c.charCodeAt(0) - 32] || " ";
        a += d === " " ? c : d;
    }
    return a;
}
const SUBSCRIPT_LOOKUP = "        ₍₎ ₊ ₋  ₀₁₂₃₄₅₆₇₈₉   ₌                                   ₐ   ₑ  ₕᵢⱼₖₗₘₙₒₚ ᵣₛₜᵤᵥ ₓ       ";
function toSubscript(x) {
    var a = "";
    for (var c of x) {
        var d = SUBSCRIPT_LOOKUP[c.charCodeAt(0) - 32] || " ";
        a += d === " " ? c : d;
    }
    return a;
}
function toBeginUpperAnyCase(x) {
    return x.slice(0, 1).toUpperCase() + x.slice(1);
}
function toBeginLowerAnyCase(x) {
    return x.slice(0, 1).toUpperCase() + x.slice(1);
}
function toBorderUpperCase(x) {
    if (x.length <= 2)
        return x.toUpperCase();
    return x.slice(0, 1).toUpperCase() + x.slice(1, -1).toLowerCase() + x.slice(-1).toUpperCase();
}
function toKebabCase(x, re = null, sep = "-") {
    var words = x.split(re || /[^0-9A-Za-z]+/g).filter(IDENTITY);
    for (var i = 0, I = words.length; i < I; ++i) {
        words[i] = words[i].replace(/[A-Z]+/g, m => m.length === 1 ? sep + m : sep + m.slice(0, -1) + sep + m.slice(-1));
        if (words[i].startsWith(sep))
            words[i] = words[i].slice(sep.length);
    }
    return words.join(sep).toLowerCase();
}
function toSnakeCase(x, re = null) {
    return toKebabCase(x, re, "_");
}
function toCamelCase(x, re = null, upper = false) {
    var a = "", words = x.split(re || /[^0-9A-Za-z]+/g).filter(IDENTITY);
    for (var w of words)
        a += toBeginUpperAnyCase(w.replace(/[A-Z]+/g, toBorderUpperCase));
    return upper ? a : toBeginLowerAnyCase(a);
}
function toPascalCase(x, re = null) {
    return toCamelCase(x, re, true);
}
function ngrams(x, n) {
    var a = [];
    for (var i = 0, I = x.length - n + 1; i < I; i++)
        a[i] = x.substring(i, i + n);
    return a;
}
function uniqueNgrams(x, n) {
    var a = new Set();
    for (var i = 0, I = x.length - n + 1; i < I; i++)
        a.add(x.substring(i, i + n));
    return a;
}
function countNgrams(x, n) {
    return Math.max(0, x.length - n + 1);
}
function countUniqueNgrams(x, n) {
    return uniqueNgrams(x, n).size;
}
function countEachNgram(x, n) {
    var a = new Map();
    for (var i = 0, I = x.length - n + 1; i < I; i++) {
        var g = x.substring(i, i + n);
        a.set(g, (a.get(g) || 0) + 1);
    }
    return a;
}
function matchingNgrams(x, y, n) {
    var gs = countEachNgram(x, n), a = [];
    for (var i = 0, I = y.length - n + 1; i < I; i++) {
        var g = y.substring(i, i + n);
        var c = gs.get(g) || 0;
        if (c) {
            a.push(g);
            gs.set(g, c - 1);
        }
    }
    return a;
}
function uniqueMatchingNgrams(x, y, n) {
    var a = new Set();
    var gs = uniqueNgrams(x, n);
    for (var i = 0, I = y.length - n + 1; i < I; i++) {
        var g = y.substring(i, i + n);
        if (gs.has(g))
            a.add(g);
    }
    return a;
}
function countMatchingNgrams(x, y, n) {
    var gs = countEachNgram(x, n), a = 0;
    for (var i = 0, I = y.length - n + 1; i < I; i++) {
        var g = y.substring(i, i + n);
        var c = gs.get(g) || 0;
        if (c) {
            a++;
            gs.set(g, c - 1);
        }
    }
    return a;
}
function countEachMatchingNgram(x, y, n) {
    var a = new Map();
    var gs = countEachNgram(x, n);
    for (var i = 0, I = y.length - n + 1; i < I; i++) {
        var g = y.substring(i, i + n);
        var c = gs.get(g) || 0;
        if (c) {
            a.set(g, (a.get(g) || 0) + 1);
            gs.set(g, c - 1);
        }
    }
    return a;
}
function countUniqueMatchingNgrams(x, y, n) {
    var gs = uniqueNgrams(x, n), a = 0;
    for (var i = 0, I = y.length - n + 1; i < I; i++) {
        var g = y.substring(i, i + n);
        if (gs.has(g)) {
            a++;
            gs.delete(g);
        }
    }
    return a;
}
function euclideanDistance(x, y) {
    var a = 0;
    for (var i = 0, I = Math.max(x.length, y.length); i < I; i++) {
        var d = (x.codePointAt(i) || 0) - (y.codePointAt(i) || 0);
        a += d * d;
    }
    return Math.sqrt(a);
}
function hammingDistance(x, y) {
    var a = 0;
    for (var i = 0, I = Math.max(x.length, y.length); i < I; i++)
        if (x.charAt(i) !== y.charAt(i))
            a++;
    return a;
}
function jaccardIndex(x, y, n) {
    var gx = countNgrams(x, n);
    var gy = countNgrams(y, n);
    var g = countMatchingNgrams(x, y, n);
    return gx + gy ? g / (gx + gy - g) : 1;
}
function jaccardDistance(x, y, n) {
    return 1 - jaccardIndex(x, y, n);
}
function sorensenDiceIndex(x, y, n) {
    var gx = countNgrams(x, n);
    var gy = countNgrams(y, n);
    var g = countMatchingNgrams(x, y, n);
    return gx + gy ? (2 * g) / (gx + gy) : 1;
}
function sorensenDiceDistance(x, y, n) {
    return 1 - sorensenDiceIndex(x, y, n);
}
function tverskyIndex(x, y, n, a = 1, b = 1) {
    var gx = countNgrams(x, n);
    var gy = countNgrams(y, n);
    var g = countMatchingNgrams(x, y, n);
    return gx + gy ? g / (g + a * (gx - g) + b * (gy - g)) : 1;
}
function tverskyDistance(x, y, n, a = 1, b = 1) {
    return 1 - tverskyIndex(x, y, n, a, b);
}
function rangedMatches(x, y, d) {
    var mx = "", my = "";
    var by = Array.from(y);
    for (var i = 0, I = x.length; i < I; i++) {
        var j = by.lastIndexOf(x.charAt(i), i);
        if (j < 0 || i - j > d)
            j = by.indexOf(x.charAt(i), i + 1);
        if (j < 0 || j - i > d)
            continue;
        mx += x.charAt(i);
        by[j] = null;
    }
    for (var j = 0, J = y.length; j < J; j++)
        if (by[j] == null)
            my += y.charAt(j);
    return [mx, my];
}
function jaroSimilarity(x, y) {
    var X = x.length, Y = y.length;
    var d = Math.floor(Math.max(X, Y) / 2) - 1;
    var [mx, my] = rangedMatches(x, y, d), m = mx.length;
    var t = hammingDistance(mx, my) / 2;
    return m ? (m / X + m / Y + (m - t) / m) / 3 : 0;
}
function jaroDistance(x, y) {
    return 1 - jaroSimilarity(x, y);
}
function jaroWinklerSimilarity(x, y, p = 0.1) {
    var s = jaroSimilarity(x, y);
    var l = longestCommonPrefix(x, y.substring(0, 4)).length;
    return s + l * p * (1 - s);
}
function jaroWinklerDistance(x, y, p = 0.1) {
    return 1 - jaroWinklerSimilarity(x, y, p);
}
function levenshteinDistance(x, y, ins = 1, del = 1, sub = 1) {
    var [x, y] = longestUncommonInfixes(x, y);
    var X = x.length, Y = y.length;
    var d0 = [], d1 = [];
    for (var j = 0, v = 0; j <= Y; v += ins)
        d0[j++] = v;
    for (var i = 1; i <= X; i++) {
        var di = i & 1 ? d1 : d0;
        var dh = i & 1 ? d0 : d1;
        di[0] = dh[0] + del;
        for (var j = 1; j <= Y; j++) {
            var cost = x[i - 1] === y[j - 1] ? 0 : sub;
            di[j] = Math.min(dh[j] + del, di[j - 1] + ins, dh[j - 1] + cost);
        }
    }
    return (X & 1 ? d1 : d0)[Y];
}
function damerauLevenshteinDistance(x, y, ins = 1, del = 1, sub = 1, tra = 1) {
    var [x, y] = longestUncommonInfixes(x, y);
    var X = x.length, Y = y.length;
    var I = X + 2, J = Y + 2, L = X + Y;
    var d0 = [L], d1 = [L];
    var d = [d0, d1], da = new Map();
    for (var j = 1, v = 0; j < J; j++, v += ins) {
        d0[j] = L;
        d1[j] = v;
    }
    for (var i = 2; i < I; i++) {
        var db = 0, dh = d[i - 1];
        var di = [L, dh[1] + del];
        d[i] = di;
        for (var j = 2; j < J; j++) {
            var k = da.get(y[j - 2]) || 0, l = db, cost = sub;
            if (x[i - 2] === y[j - 2]) {
                db = j - 1;
                cost = 0;
            }
            di[j] = Math.min(di[j - 1] + ins, dh[j] + del, dh[j - 1] + cost, d[k][l] + (i - k - 2) + tra + (j - l - 2));
        }
        da.set(x[i - 2], i - 1);
    }
    return d[X + 1][Y + 1];
}

export { DIGITS, HEX_DIGITS, LETTERS, LOWERCASE, MAX_CODE_POINT, MIN_CODE_POINT, OCT_DIGITS, PRINTABLE, PUNCTUATION, UPPERCASE, WHITESPACE, get as at, begin, charAt, charCodeAt, codePointAt, codePointRange, compare, concat, countEachMatchingNgram, countEachNgram, countMatchingNgrams, countNgrams, countUniqueMatchingNgrams, countUniqueNgrams, damerauLevenshteinDistance, end, endsWith, euclideanDistance, filter, from, fromCharCode, fromCodePoint, get, getAll, hammingDistance, includes, index, indexOf, indexRange, middle as infix, is, isCharacter, isEmpty, isEqual, includes as isInfix, startsWith as isPrefix, endsWith as isSuffix, jaccardDistance, jaccardIndex, jaroDistance, jaroSimilarity, jaroWinklerDistance, jaroWinklerSimilarity, lastIndexOf, begin as left, length, levenshteinDistance, localeCompare, longestCommonInfix, longestCommonPrefix, longestCommonSuffix, longestUncommonInfixes, match, matchAll, matchingNgrams, middle, ngrams, normalize, of, padEnd, padStart, begin as prefix, repeat, replace, reverse, end as right, search, set, length as size, slice, sorensenDiceDistance, sorensenDiceIndex, sort, spaces, splice, split, startsWith, substring, end as suffix, toBaseline, toCamelCase, toKebabCase, toLocaleLowerCase, toLocaleUpperCase, toLowerCase, toPascalCase, toSnakeCase, toString, toSubscript, toSuperscript, toUpperCase, trim, trimEnd, trimStart, tverskyDistance, tverskyIndex, uniqueMatchingNgrams, uniqueNgrams, valueOf };
